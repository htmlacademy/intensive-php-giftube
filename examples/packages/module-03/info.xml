<?xml version="1.0" encoding="utf-8"?>
<examples>
  <example name="Подключение файлов" index="1">
    <description>to do</description>
    <files>
      <file name="index.php" main="true" show="true">
        <intro order="1">В этой демке мы научимся подключать в сценарий другие файлы.

          Этот файл является основным сценарием, который будет подключать внутри себя всё
          остальное: конфиги, данные, функции и шаблоны.
        </intro>
        <states>
          <state order="2">Вначале подключим все необходимые файлы, которые понадобятся на этой странице. funcs.php -
            содержит функцию для урезания текста, в config.php находятся настройки сайта, а data.php
            содержит массивы гифок и категорий
          </state>
          <state order="7">Теперь напишем условие, которое будет проверять состояние сайта: включен он или находится на
            обслуживании
          </state>
          <state order="8" reload="true">Если сайт включен, то подключим сценарий с содержимым главной страницы</state>
          <state order="9" reload="true">Если сайт выключен на обслуживание, то подключим сценарий с текстом сообщения об ошибке
          </state>
        </states>
      </file>
      <file name="config.php" main="false" show="true">
        <intro order="3">Файл конфигурации. Здесь задаются основные параметры сайта: название и путь к шаблонам.
          Также здесь присутствует важная опция - статус работы сайта. За него отвечает ключ "enable". Если он
          равен false, то вместо страниц сайта будет показана заглушка.
        </intro>
        <states/>
      </file>
      <file name="data.php" main="false" show="true">
        <intro order="4">Здесь мы храним все данные, которые затем передадим в шаблоны. Это список категорий и гифок.</intro>
        <states/>
      </file>
      <file name="tpl/main.php" main="false" show="true">
        <intro order="5">Это шаблон главной страницы. Он показывает список категорий и гифок. Мы подключим его, если
          в конфиге сайта опция "enable" будет равна true.
        </intro>
        <states/>
      </file>
      <file name="tpl/off.php" main="false" show="true">
        <intro order="6">Это шаблон заглушки. Мы подключим его, если в конфиге сайта опция "enable" будет равна false.</intro>
        <states/>
      </file>
      <file name="funcs.php" main="false" show="false">
        <states/>
      </file>
    </files>
  </example>
  <example name="Шаблонизация" index="2">
    <description>to do</description>
    <files>
      <file name="index.php" main="true" show="true">
        <intro order="1">В этой демке посмотрим как выносить верстку в отдельные шаблоны, а затем подключать и показывать
        их в своих сценариях.</intro>
        <states>
          <state order="2">Подключаем сценарий с функцией-шаблонизатором, а также необходимые данные для показа страницы
            (гифки, категории)
          </state>
          <state order="4">Напишем функцию, которая принимает timestamp и возвращает дату в человеческом виде
          </state>
          <state order="7">Вначале с помощью функции-шаблонизатора подключаем и получаем содержимое шаблона главной
            страницы. Передаем в этот шаблон нужные ему данные - массив с гифками
          </state>
          <state order="8">Теперь подключаем наш лейаут. Передадим туда содержимое шаблона страницы, а также пару других
            переменных
          </state>
          <state order="10" reload="true">Последним шагом выводим содержимое лейаута на экран</state>
        </states>
      </file>
      <file name="templates/_gif.php" main="false" show="true">
        <intro order="6">Шаблон блока. Здесь блоком является превью гифки. В этот блок мы передаем ассоциативный массив со всей
        информацией для показа гифки.</intro>
        <states/>
      </file>
      <file name="templates/layout.php" main="false" show="true">
        <intro order="9">Это особый шаблон - лейаут. Здесь находится общая для всех страниц верстка: шапка сайта, футер,
        подключаемые стили и тому подобные вещи. В лейаут также встраивается шаблон самой страницы. Т.е. один лейаут является
        основой для показа разных страниц сайта.</intro>
        <states/>
      </file>
      <file name="templates/main.php" main="false" show="true">
        <intro order="5">А это шаблон главной страницы. Он очень просто и состоит из заголовка и подключения блока с превью
        гифки. В качестве данных в этот шаблон передается двумерный массив со списком гифок.</intro>
        <states/>
      </file>
      <file name="data.php" main="false" show="true">
        <intro order="3">Здесь данные для шаблона главной страницы.</intro>
        <states/>
      </file>
      <file name="functions.php" main="false" show="false">
        <states/>
      </file>
    </files>
  </example>
  <example name="Фильтрация данных" index="3">
    <description>to do</description>
    <files>
      <file name="index.php" main="true" show="true">
        <intro order="1">При показе в шаблонах информации, полученной от пользователя, необходимо быть особенно осторожным.
        Все поступающие извне данные нужно обязательно фильтровать, чтобы обезопасить свой сайт от атаки вида XSS. В этой демке
        посмотрим как правильно показывать на странице сообщение, полученное от пользователя через форму.</intro>
        <states>
          <state order="2">Напишем простую функцию-обертку, которая будет фильтровать содержимое и возвращать строку,
            очищенную от опасных спецсимволов
          </state>
          <state order="3">Получим комментарии в виде массива</state>
          <state order="8" reload="true">Подключим лейаут, шаблон и передадим туда данные из формы</state>
        </states>
      </file>
      <file name="templates/layout.php" main="false" show="false">
        <states/>
      </file>
      <file name="templates/view.php" main="false" show="true">
        <intro order="4">Это шаблон для страницы просмотра гифки. Здесь у нас выводятся комментарии, полученные от пользователя.
        Текст каждого комментарии предварительно обрабатывается функцией esc, которая заменит все опасные спецсимволы в тексте
        комментария на их безопасные аналоги.</intro>
        <states>
          <state order="5">Сделаем цикл для вывода списка комментариев</state>
          <state order="6">Каждый комментарий находится в отдельном теге "article"</state>
          <state order="7">Текст комментария перед показом на странице обязательно обрабатываем своей функцией</state>
        </states>
      </file>
      <file name="post.php" main="false" show="false">
        <states/>
      </file>
    </files>
  </example>
  <example name="Дата и время" index="4">
    <description>to do</description>
    <files>
      <file name="date.php" main="true" show="true">
        <intro order="1">Стандартные функции для работы с датой и временем очень часто используются в PHP. Сейчас мы научимся
          показывать дату в удобном формате, локализовывать формат даты, а также сделаем счетчик, которые покажет количество дней
          до определенной даты.</intro>
        <states>
          <state order="2" reload="true">Функция date принимает формат даты и возвращает текущую дату/время в этом формате.
            В данном примере мы получаем дату в виде "день.месяц.год", как это принято в России.
          </state>
          <state order="3" reload="true">В формате могут быть не только части даты, но и время: часы, минуты, секунды. Поэтому также
            просто можно узнать и который сейчас час в формате "часы:минуты:секунды".
          </state>
          <state order="4" reload="true">Функции даты всегда возвращают время с учетом часового пояса. Пояс по умолчанию указан в
            настройках, но его всегда можно поменять в скрипте. Это позволит легко узнать сколько сейчас
            времени в любом городе планеты.
          </state>
          <state order="5" reload="true">Указав в качестве дефолтной локали Россию и русский язык, можно даже получить название
            текущего дня недели.
          </state>
          <state order="6" reload="true">Всего за три строчки кода можно написать счетчик дней до наступления любого события.
            Например, нового года. Здесь мы вначале проверяем год на високосность, затем получаем
            порядковый номер текущего дня и отнимаем его от кол-ва дней в этом году.
          </state>
        </states>
      </file>
      <file name="timestamp.php" main="false" show="true">
        <intro order="7">А теперь давайте научимся выполнять различные операции с датой, используя формат временной метки
        (UNIXTIME).</intro>
        <states>
          <state order="7" reload="true">Узнать текущий unix timestamp очень просто - для этого надо вызвать функцию time() без
            всяких аргументов
          </state>
          <state order="8" reload="true">Функция strtotime умеет возвращать timestamp не только для текущего момента, но и
            для любой другой даты. Причем формат даты может быть практически произвольным.
          </state>
          <state order="9" reload="true">Имея timestamp для двух разных дат, можно вычесть одно из другого, чтобы получить
            разницу между датами в секундах. Затем, чтобы из секунд получились дни, просто поделим это число
            на количество секунд в сутках.
          </state>
          <state order="10" reload="true">Точно также можно поступить и со временем. Например, давайте узнаем сколько осталось часов
            и минут до полуночи. Получим ts полуночи, отнимем текущий ts, а результат поделим на количество
            секунд в часе и в минуте.
          </state>
        </states>
      </file>
      <file name="date_time.php" main="false" show="true">
        <intro order="11">
          PHP предлагает еще один очень удобный способ манипуляции с датой и временем - встроенные функции date_. С их
          помощью можно складывать, вычитать, форматировать и узнавать разницу не прибегая к метке времени (timestamp).
          Разберем задачи из timestamp.php, но без использования unixtime.</intro>
          <states>
            <state order="12">Установим дату окончания интенсива</state>
            <state order="13">Создадим новый экземпляр даты окончания на основе строки</state>
            <state order="14">Создадим еще один экземпляр даты с текущим временем</state>
            <state order="15">Узнаем разницу между двумя датами и получим результат в виде экземпляра типа "временной интервал"</state>
            <state order="16">Отформатируем данный интервал в формате "только дни"</state>
            <state order="17" reload="true">Покажем итоговый результат</state>
            <state order="18">Посмотрим как можно складывать даты. Узнаем, какая дата будет через 23 дня. Для этого создадим
            интервал в эти самые 23 дня.</state>
            <state order="19">Добавим к текущей дате наш интервал</state>
            <state order="20">Полученную дату отформатируем к привычному формату дд.мм.гггг</state>
            <state order="21" reload="true">Покажем итоговый результат</state>
          </states>
      </file>
    </files>
  </example>
</examples>
